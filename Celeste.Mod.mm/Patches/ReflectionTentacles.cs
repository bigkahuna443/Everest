#pragma warning disable CS0649 // Field is never assigned to, and will always have its default value null

using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Monocle;
using System.Collections.Generic;
using MonoMod;

namespace Celeste {
    public class patch_ReflectionTentacles : ReflectionTentacles {
        /// <summary>
        /// Slightly faster than not providing a comparer, which is important in a hot path like this.
        /// Used by <see cref="Quad(ref int, Vector2, Vector2, Vector2, Vector2, MTexture)"/>.
        /// </summary>
        private struct MTextureComparer : IEqualityComparer<MTexture> {
            public bool Equals(MTexture x, MTexture y) => ReferenceEquals(x, y);

            public int GetHashCode(MTexture obj) => obj.GetHashCode();
        }

        /// <summary>
        /// Stores a set of UV's needed to render a sprite. Used for caching by <see cref="Quad(ref int, Vector2, Vector2, Vector2, Vector2, MTexture)"/>.
        /// </summary>
        private struct UVSet {
            public Vector2 TopLeft;
            public Vector2 TopRight;
            public Vector2 BottomLeft;
            public Vector2 BottomRight;
        }

        /// <summary>
        /// A cache used by <see cref="Quad(ref int, Vector2, Vector2, Vector2, Vector2, MTexture)"/>.
        /// </summary>
        private Dictionary<MTexture, UVSet> UVCache;

        [MonoModIgnore]
        private VertexPositionColorTexture[] vertices;

        // patch the method to significantly improve performance
        [MonoModReplace]
        private unsafe void Quad(ref int n, Vector2 a, Vector2 b, Vector2 c, Vector2 d, MTexture subtexture) {
            subtexture ??= GFX.Game["util/pixel"];
            UVCache ??= new(33, new MTextureComparer()); // 33 is the amount of MTextures used by each tentacle entity.

            // retrieve UV's from a cache. Because VirtualTexture.Texture_Safe is really expensive (due to lazy loading), this is very important for performance.
            if (!UVCache.TryGetValue(subtexture, out UVSet uv)) {
                Texture2D texture = ((patch_VirtualTexture)(object)subtexture.Texture).Texture_Safe;
                Rectangle clipRect = subtexture.ClipRect;
                float widthUnit = 1f / texture.Width;
                float heightUnit = 1f / texture.Height;

                uv = new UVSet() {
                    TopLeft = new Vector2(clipRect.Left * widthUnit, clipRect.Top * heightUnit),
                    TopRight = new Vector2(clipRect.Right * widthUnit, clipRect.Top * heightUnit),
                    BottomLeft = new Vector2(clipRect.Left * widthUnit, clipRect.Bottom * heightUnit),
                    BottomRight = new Vector2(clipRect.Right * widthUnit, clipRect.Bottom * heightUnit),
                };

                UVCache[subtexture] = uv;
            }

            // we'll use unsafe code to replace 6 access checks (generated by the JIT) with just one.
            if (n + 5 >= vertices.Length) {
                return;
            }

            fixed (VertexPositionColorTexture* verts = &vertices[n]) {
                verts[0].Position.X = a.X;
                verts[0].Position.Y = a.Y;
                verts[0].TextureCoordinate = uv.TopLeft;

                verts[1].Position.X = b.X;
                verts[1].Position.Y = b.Y;
                verts[1].TextureCoordinate = uv.TopRight;

                verts[2].Position.X = d.X;
                verts[2].Position.Y = d.Y;
                verts[2].TextureCoordinate = uv.BottomLeft;

                verts[3].Position.X = d.X;
                verts[3].Position.Y = d.Y;
                verts[3].TextureCoordinate = uv.BottomLeft;

                verts[4].Position.X = b.X;
                verts[4].Position.Y = b.Y;
                verts[4].TextureCoordinate = uv.TopRight;

                verts[5].Position.X = c.X;
                verts[5].Position.Y = c.Y;
                verts[5].TextureCoordinate = uv.BottomRight;
            }
            n += 6;
        }
    }
}
